# -*- coding: utf-8 -*-"""	基于回溯法的旅行商问题解法Python源码		Author:		Greatpan	Date:		2018.10.10"""import numpy as npclass AntList(object):	def __init__(self,distfunc,getEtatable,numant=5,numcity=10,alpha=1,rho=0.1,Q=1):		""" 构造函数 """		self.numant = numant		# 蚂蚁个数		self.numcity = numcity		# 城市个数		self.alpha = alpha			# 信息素重要程度因子		self.rho = rho				# 信息素的挥发速度		self.Q = Q					# 品质因子		self.distfunc=distfunc		self.getEtatable=getEtatable		self.bestantunit=None		self.population=[]		self.pathtable = np.zeros((self.numant,self.numcity)).astype(int)	# 路径记录表		self.generation=0	def Init_eta_phe(self):		"""			函数名：Init_eta_phe(self)			函数功能：	对启发函数和信息素进行初始化				输入	1 	self：类自身				输出	1	无			其他说明：无		"""		self.etatable = self.getEtatable()			# 启发函数矩阵，表示蚂蚁从城市i转移到矩阵j的期望程度		self.pheromonetable  = np.ones((self.numcity,self.numcity))			# 信息素矩阵	def InitStartPosition(self):		"""			函数名：InitStartPosition(self)			函数功能：	初始化蚂蚁的起始位置				输入	1 	self：类自身				输出	1	无			其他说明：无		"""		#  随机产生各个蚂蚁的起点城市		if self.numant <= self.numcity:   	# 城市数比蚂蚁数多			self.pathtable[:,0] = np.random.permutation(range(0,self.numcity))[:self.numant]		else:                   			# 蚂蚁数比城市数多，需要补足			self.pathtable[:self.numcity,0] = np.random.permutation(range(0,self.numcity))[:]			self.pathtable[self.numcity:,0] = np.random.permutation(range(0,self.numcity))[:self.numant-self.numcity]	def upDateInf(self):		"""			函数名：upDateInf(self)			函数功能：	对信息素进行更新				输入	1 	self：类自身				输出	1	无			其他说明：无		"""		changepheromonetable = np.zeros((self.numcity,self.numcity))				if self.population:			for antunit in self.population:				for i in range(self.numcity-1):					changepheromonetable[antunit.path[i]][antunit.path[i+1]] += self.Q/antunit.length				changepheromonetable[antunit.path[self.numcity-1]][antunit.path[0]] += self.Q/antunit.length			self.pheromonetable = (1-self.rho)*self.pheromonetable + changepheromonetable		else:			self.Init_eta_phe()	def getNextCity(self,unvisited,visiting):		"""			函数名：getNextCity(self,unvisited,visiting)			函数功能：	根据信息素和启发函数矩阵，通过轮盘赌法随机选下一个城市				输入	1 	self：类自身				输入 2	unvisited：未走过的城市列表				输入 2	visited：已经走过的城市列表				输出	1	k：下一个城市的编号			其他说明：无		"""		listunvisited = list(unvisited)		probtrans = np.zeros(len(listunvisited))		for k in range(len(listunvisited)):			probtrans[k] = np.power(self.pheromonetable[visiting][listunvisited[k]],self.alpha)\				*np.power(self.etatable[visiting][listunvisited[k]],self.alpha)		cumsumprobtrans = (probtrans/sum(probtrans)).cumsum()		cumsumprobtrans -= np.random.rand()		k = listunvisited[np.where(cumsumprobtrans>0)[0][0]] # 下一个要访问的城市		return k	def GoOnePath(self,i):		"""			函数名：distance(self, path)			函数功能：	第i只蚂蚁从随机点出发找到一条路径				输入	1 	self：类自身				输入 2	i：当代的第i只蚂蚁				输出	1	antunit：一个蚂蚁单元类			其他说明：无		"""		visiting = self.pathtable[i,0]		# 当前所在的城市		unvisited = set(range(self.numcity))# 未访问的城市		unvisited.remove(visiting)			# 删除元素				for j in range(1,self.numcity):		# 循环numcity-1次，访问剩余的numcity-1个城市			# 每次用轮盘法选择下一个要访问的城市			k=self.getNextCity(unvisited,visiting)						self.pathtable[i,j] = k			unvisited.remove(k)			visiting = k				antunit=AntUnit(self.pathtable[i],self.distfunc(self.pathtable[i]))		if self.bestantunit:			if self.bestantunit.length>antunit.length:				self.bestantunit=antunit		else:			self.bestantunit=antunit				return antunit	def nextGeneration(self):		"""			函数名：nextGeneration(self)			函数功能：	产生下一代				输入	1 	self：类自身				输出	1	无			其他说明：无		"""		self.upDateInf()		newPopulation = []						# 新种群		for i in range(self.numant):			newPopulation.append(self.GoOnePath(i))		self.population = newPopulation		self.generation += 1class AntUnit(object):	"""		类名：GAUnit		类说明：	遗传算法个体类	"""	def __init__(self, aPath = None,aLength = -1):		""" 构造函数 """		self.path = list(aPath)			# 个体的基因序列		self.length = aLength  			# 初始化适配值